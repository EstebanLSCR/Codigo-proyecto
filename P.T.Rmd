---
title: "P.T.R"
author: "Marco Mejia Elizondo"
date: "1/11/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(fitdistrplus)
library(actuar)
library(kutils)
library(tidyr)
library(xtable)
library(dplyr)
#library(vioplot)
library(ggplot2)
library(readxl)
library(rriskDistributions)
library(lubridate)

defraudaciones <- read_excel("Defraudaciones enero-junio 2020.xlsx")
```


```{r}
fechas <- defraudaciones$FechaRegistro

# F.lambda.Diario <- function(fechas){
#   return( as.double( mean( fechas[-1] - fechas[-length(fechas)]) ) )
# }
# 
# F.lambda.Semestral <- function(fechas){
#   return( as.double( mean( fechas[-1] - fechas[-length(fechas)])/(365/2) ) )
# }
# 
# F.lambda.Diario(fechas)
# 
# F.lambda.Semestral(sort(fechas))


# meses <- month(defraudaciones$FechaRegistro)
# 
# enero=0
# febrero=0
# marzo=0
# abril=0
# mayo=0
# junio=0
# for (i in 1:length(meses)){
#   if(meses[i]==1){
#        enero=enero+1
#        }
#     else if(meses[i]==2){
#        febrero=febrero+1
#        }
#     else if(meses[i]==3){
#        marzo=marzo+1
#        }
# 
#     else if(meses[i]==4)
#        abril=abril+1
# 
#     else if(meses[i]==5)
#        mayo=mayo+1
#        
#     else if(meses[i]==6){
#        junio=junio+1}
# 
# }
# 
# 
# meses2 = c(enero,febrero,marzo,abril,mayo,junio)
# meses2
# 
# mean(meses2)








# Pasar a Python
Datos <- data.frame(Fechas = fechas) 

min(Datos$Fechas)
max(Datos$Fechas)

unique(sort(fechas))

diasT <- seq.Date(from = ymd(20200101), to = ymd(20200630), by = "day")
diasTn <- c(1:length(diasT))

for (i in 1:length(diasT)) {
  diasTn[i] <- sum(Datos$Fechas == diasT[i])
}

diasTn
cumsum(diasTn)



F.pois <- fitdist(diasTn, "pois")

plot(F.pois)
plot(F.pois, demp = TRUE)
plot(F.pois, histo = FALSE, demp = TRUE)
cdfcomp(F.pois, addlegend=FALSE)
denscomp(F.pois, addlegend=FALSE)
ppcomp(F.pois, addlegend=FALSE)
qqcomp(F.pois, addlegend=FALSE)

# sum(c(0,20,1,0,0,0,0,9,1,1,0,0,0,1,10,1,8,0,0,0,0,0,15,0,0,0,0,1,15,0,1,0,0,0,0,17,0,0,0,0,0,0,7,16,12,0,0,0,0,6,0,1,0,0,6,0,0,1,0,0,0,12,0,9,10,18,0,0,2,0,19,1,0,0,0,1,1,15,2,1,0,0,24,0,1,2,14,0,0,3,4,27,0,34,0,0,0,0,0,0,0,0,0,0,0,0,1,11,0,0,0,0,1,6,0,0,0,0,28,0,0,0,0,0,25,0,5,8,2,0,0,0,16,2,1,0,0,0,0,31,2,14,32,0,0,4,23,4,7,2,0,0,1,22,14,0,0,0,0,0,51,0,7,1,0,0,4,7,4,0,7,0,0,1,16,6,28,8,0,0,0,0))


# chisquare(diasTn, [np.mean(dias)]*len(dias)) #Python
```


```{r}
F.nbinom <- fitdist(diasTn, "nbinom")

plot(F.nbinom)
plot(F.nbinom, demp = TRUE)
plot(F.nbinom, histo = FALSE, demp = TRUE)
cdfcomp(F.nbinom, addlegend=FALSE)
denscomp(F.nbinom, addlegend=FALSE)
ppcomp(F.nbinom, addlegend=FALSE)
qqcomp(F.nbinom, addlegend=FALSE)

panual <- (F.nbinom$estimate[[1]]*365)/(F.nbinom$estimate[[2]]+F.nbinom$estimate[[1]]*365)
F.nbinom$estimate
c(F.nbinom$estimate[[1]]*365, panual)
```
```{r}
size <- F.nbinom$estimate[[1]]
mu <- F.nbinom$estimate[[2]]
p <- (F.nbinom$estimate[[1]])/(F.nbinom$estimate[[2]]+F.nbinom$estimate[[1]])
#(length(diasTn))/(F.nbinom$estimate[[2]]+length(diasTn))

size
mu
p
```

```{r}
mu + mu^2/size
size*(1-p)/p
```


```{r}
p <- mean(diasTn)/var(diasTn)
n <- mean(diasTn)^2/(var(diasTn)-mean(diasTn))
n
p




miu <- n*(1-p)/p
sigma2 <- n*(1-p)/p^2



n <- length(diasTn)
miu <- mean(diasTn)
prob <- n/(n+miu)
size <- (prob*miu)/(1-prob)

prob
size
```






```{r}
F.geom <- fitdist(diasTn, "geom")
plot(F.geom)
plot(F.geom, demp = TRUE)
plot(F.geom, histo = FALSE, demp = TRUE)
cdfcomp(F.geom, addlegend=FALSE)
denscomp(F.geom, addlegend=FALSE)
ppcomp(F.geom, addlegend=FALSE)
qqcomp(F.geom, addlegend=FALSE)
```


```{r}
function (data, distr, method = c("mle", "mme", "qme", "mge", 
    "mse"), start = NULL, fix.arg = NULL, discrete, keepdata = TRUE, 
    keepdata.nb = 100, ...) 
{
    if (!is.character(distr)) 
        distname <- substring(as.character(match.call()$distr), 
            2)
    else distname <- distr
    ddistname <- paste("d", distname, sep = "")
    if (!exists(ddistname, mode = "function")) 
        stop(paste("The ", ddistname, " function must be defined"))
    if (missing(discrete)) {
        if (is.element(distname, c("binom", "nbinom", "geom", 
            "hyper", "pois"))) 
            discrete <- TRUE
        else discrete <- FALSE
    }
    if (!is.logical(discrete)) 
        stop("wrong argument 'discrete'.")
    if (!is.logical(keepdata) || !is.numeric(keepdata.nb) || 
        keepdata.nb < 2) 
        stop("wrong arguments 'keepdata' and 'keepdata.nb'")
    if (any(method == "mom")) 
        warning("the name \"mom\" for matching moments is NO MORE used and is replaced by \"mme\"")
    method <- match.arg(method, c("mle", "mme", "qme", "mge", 
        "mse"))
    if (method %in% c("mle", "mme", "mge", "mse")) 
        dpq2test <- c("d", "p")
    else dpq2test <- c("d", "p", "q")
    if (!(is.vector(data) & is.numeric(data) & length(data) > 
        1)) 
        stop("data must be a numeric vector of length greater than 1")
    my3dots <- list(...)
    if (length(my3dots) == 0) 
        my3dots <- NULL
    n <- length(data)
    arg_startfix <- manageparam(start.arg = start, fix.arg = fix.arg, 
        obs = data, distname = distname)
    argddistname <- names(formals(ddistname))
    hasnodefaultval <- sapply(formals(ddistname), is.name)
    arg_startfix <- checkparamlist(arg_startfix$start.arg, arg_startfix$fix.arg, 
        argddistname, hasnodefaultval)
    if (is.function(fix.arg)) 
        fix.arg.fun <- fix.arg
    else fix.arg.fun <- NULL
    resdpq <- testdpqfun(distname, dpq2test, start.arg = arg_startfix$start.arg, 
        fix.arg = arg_startfix$fix.arg, discrete = discrete)
    if (any(!resdpq$ok)) {
        for (x in resdpq[!resdpq$ok, "txt"]) warning(x)
    }
    if (method == "mme") {
        if (!is.element(distname, c("norm", "lnorm", "pois", 
            "exp", "gamma", "nbinom", "geom", "beta", "unif", 
            "logis"))) 
            if (!"order" %in% names(my3dots)) 
                stop("moment matching estimation needs an 'order' argument")
        mme <- mmedist(data, distname, start = arg_startfix$start.arg, 
            fix.arg = arg_startfix$fix.arg, checkstartfix = TRUE, 
            ...)
        sd <- NULL
        correl <- varcovar <- NULL
        estimate <- mme$estimate
        loglik <- mme$loglik
        npar <- length(estimate)
        aic <- -2 * loglik + 2 * npar
        bic <- -2 * loglik + log(n) * npar
        convergence <- mme$convergence
        fix.arg <- mme$fix.arg
        weights <- mme$weights
    }
    else if (method == "mle") {
        mle <- mledist(data, distname, start = arg_startfix$start.arg, 
            fix.arg = arg_startfix$fix.arg, checkstartfix = TRUE, 
            ...)
        if (mle$convergence > 0) 
            stop("the function mle failed to estimate the parameters, \n                with the error code ", 
                mle$convergence, "\n")
        estimate <- mle$estimate
        if (!is.null(mle$hessian)) {
            if (all(!is.na(mle$hessian)) && qr(mle$hessian)$rank == 
                NCOL(mle$hessian)) {
                varcovar <- solve(mle$hessian)
                sd <- sqrt(diag(varcovar))
                correl <- cov2cor(varcovar)
            }
            else {
                varcovar <- NA
                sd <- NA
                correl <- NA
            }
        }
        else {
            varcovar <- NA
            sd <- NA
            correl <- NA
        }
        loglik <- mle$loglik
        npar <- length(estimate)
        aic <- -2 * loglik + 2 * npar
        bic <- -2 * loglik + log(n) * npar
        convergence <- mle$convergence
        fix.arg <- mle$fix.arg
        weights <- mle$weights
    }
    else if (method == "qme") {
        if (!"probs" %in% names(my3dots)) 
            stop("quantile matching estimation needs an 'probs' argument")
        qme <- qmedist(data, distname, start = arg_startfix$start.arg, 
            fix.arg = arg_startfix$fix.arg, checkstartfix = TRUE, 
            ...)
        estimate <- qme$estimate
        sd <- NULL
        loglik <- qme$loglik
        npar <- length(estimate)
        aic <- -2 * loglik + 2 * npar
        bic <- -2 * loglik + log(n) * npar
        correl <- varcovar <- NULL
        convergence <- qme$convergence
        fix.arg <- qme$fix.arg
        weights <- qme$weights
    }
    else if (method == "mge") {
        if (!"gof" %in% names(my3dots)) 
            warning("maximum GOF estimation has a default 'gof' argument set to 'CvM'")
        mge <- mgedist(data, distname, start = arg_startfix$start.arg, 
            fix.arg = arg_startfix$fix.arg, checkstartfix = TRUE, 
            ...)
        estimate <- mge$estimate
        sd <- NULL
        loglik <- mge$loglik
        npar <- length(estimate)
        aic <- -2 * loglik + 2 * npar
        bic <- -2 * loglik + log(n) * npar
        correl <- varcovar <- NULL
        convergence <- mge$convergence
        fix.arg <- mge$fix.arg
        weights <- NULL
    }
    else if (method == "mse") {
        mse <- msedist(data, distname, start = arg_startfix$start.arg, 
            fix.arg = arg_startfix$fix.arg, checkstartfix = TRUE, 
            ...)
        estimate <- mse$estimate
        sd <- NULL
        loglik <- mse$loglik
        npar <- length(estimate)
        aic <- -2 * loglik + 2 * npar
        bic <- -2 * loglik + log(n) * npar
        correl <- varcovar <- NULL
        convergence <- mse$convergence
        fix.arg <- mse$fix.arg
        weights <- mse$weights
    }
    else {
        stop("match.arg() did not work correctly")
    }
    if (!is.null(fix.arg)) 
        fix.arg <- as.list(fix.arg)
    if (keepdata) {
        reslist <- list(estimate = estimate, method = method, 
            sd = sd, cor = correl, vcov = varcovar, loglik = loglik, 
            aic = aic, bic = bic, n = n, data = data, distname = distname, 
            fix.arg = fix.arg, fix.arg.fun = fix.arg.fun, dots = my3dots, 
            convergence = convergence, discrete = discrete, weights = weights)
    }
    else {
        n2keep <- min(keepdata.nb, n) - 2
        imin <- which.min(data)
        imax <- which.max(data)
        subdata <- data[sample((1:n)[-c(imin, imax)], size = n2keep, 
            replace = FALSE)]
        subdata <- c(subdata, data[c(imin, imax)])
        reslist <- list(estimate = estimate, method = method, 
            sd = sd, cor = correl, vcov = varcovar, loglik = loglik, 
            aic = aic, bic = bic, n = n, data = subdata, distname = distname, 
            fix.arg = fix.arg, fix.arg.fun = fix.arg.fun, dots = my3dots, 
            convergence = convergence, discrete = discrete, weights = weights)
    }
    return(structure(reslist, class = "fitdist"))
}
```

















```{r}

recl1 <- log(defraudaciones$MontoHistorico)
recl2 <- defraudaciones$MontoHistorico

res1 <- fit.cont(data2fit=recl1)


# fitdist(log((defraudaciones$MontoHistorico), "pareto")
# fitdist(defraudaciones$MontoHistorico, "pareto")
# fitdist(((defraudaciones %>% filter(MontoHistorico>221194.94))$MontoHistorico), "pareto")
# hist(recl1)
# hist(recl2)

hist((defraudaciones %>% filter(MontoHistorico>7000000))$MontoHistorico)
hist(log((defraudaciones %>% filter(MontoHistorico>7000000))$MontoHistorico))


# 75%
x1 <- (defraudaciones %>% filter(MontoHistorico>221194.94))$MontoHistorico
x2 <- log((defraudaciones %>% filter(MontoHistorico>221194.94))$MontoHistorico)

# fit.cont(data2fit=x1)
# fit.cont(data2fit=x2)

# 99%
y1 <- (defraudaciones %>% filter(MontoHistorico>3074637))$MontoHistorico
y2 <- log((defraudaciones %>% filter(MontoHistorico>3074637))$MontoHistorico)

# fit.cont(data2fit=y1)
# fit.cont(data2fit=y2)
```

```{r}
quantile(defraudaciones$MontoHistorico,0.99)
```


```{r}
hist(((defraudaciones %>% filter(MontoHistorico<7000000))$MontoHistorico))
hist(log((defraudaciones %>% filter(MontoHistorico<7000000))$MontoHistorico))
```

```{r}
defraudaciones <- defraudaciones %>% mutate(MesD = month(defraudaciones$FechaDescubrimiento),
                                            MesO = month(defraudaciones$FechaOcurrencia),
                                            MesR = month(defraudaciones$FechaRegistro))

plot(defraudaciones$MesD)
plot(defraudaciones$MesO)
plot(defraudaciones$MesR)

defraudaciones


# "O" ocurrencia
# "D" descubrimiento
F.Frecuencias <- function(datos, tipo){
  if(tipo == "R"){
      datost <- datos %>% mutate(Mes = month(datos$FechaRegistro))
    }else{
      datost <- datos %>% mutate(Mes = month(datos$FechaDescubrimiento))
    }
  
  frec <- c()
  
    for (i in 1:12) {
      frec[i] <- count(datost %>% filter(Mes == i))[[1]]
    }
  return( frec )
}

frecuencias.R <- F.Frecuencias(defraudaciones, "R")[1:6]
# frecuencias.D <- F.Frecuencias(defraudaciones, "D")


chisq.test(frecuencias.R)
# chisq.test(frecuencias.O)

```


```{r}
frecuencias.R
# frecuencias.D
```


```{r}

# x1 <- defraudaciones %>% filter(MesD==1)
# ggplot(x1, aes(x=log(MontoHistorico))) +
#   geom_histogram() +
#   geom_vline(xintercept=quantile(log(x1$MontoHistorico), 0.25)[[1]], color="red") +
#   geom_vline(xintercept=quantile(log(x1$MontoHistorico), 0.75)[[1]], color = "red")
# 
# 
# x2 <- defraudaciones %>% filter(MesD==2)
# ggplot(x2, aes(x=log(MontoHistorico))) +
#   geom_histogram() +
#   geom_vline(xintercept=quantile(log(x2$MontoHistorico), 0.25)[[1]], color="red") +
#   geom_vline(xintercept=quantile(log(x2$MontoHistorico), 0.75)[[1]], color = "red")
# 
# x3 <- defraudaciones %>% filter(MesD==3)
# ggplot(x3, aes(x=log(MontoHistorico))) +
#   geom_histogram() +
#   geom_vline(xintercept=quantile(log(x3$MontoHistorico), 0.25)[[1]], color="red") +
#   geom_vline(xintercept=quantile(log(x3$MontoHistorico), 0.75)[[1]], color = "red")
# 
# x4 <- defraudaciones %>% filter(MesD==4)
# ggplot(x4, aes(x=log(MontoHistorico))) +
#   geom_histogram() +
#   geom_vline(xintercept=quantile(log(x4$MontoHistorico), 0.25)[[1]], color="red") +
#   geom_vline(xintercept=quantile(log(x4$MontoHistorico), 0.75)[[1]], color = "red")
# 
# x5 <- defraudaciones %>% filter(MesD==5)
# ggplot(x5, aes(x=log(MontoHistorico))) +
#   geom_histogram() +
#   geom_vline(xintercept=quantile(log(x5$MontoHistorico), 0.25)[[1]], color="red") +
#   geom_vline(xintercept=quantile(log(x5$MontoHistorico), 0.75)[[1]], color = "red")
# 
# x6 <- defraudaciones %>% filter(MesD==6)
# ggplot(x6, aes(x=log(MontoHistorico))) +
#   geom_histogram() +
#   geom_vline(xintercept=quantile(log(x6$MontoHistorico), 0.25)[[1]], color="red") +
#   geom_vline(xintercept=quantile(log(x6$MontoHistorico), 0.75)[[1]], color = "red")
# 
# x7 <- defraudaciones %>% filter(MesD==7)
# ggplot(x7, aes(x=log(MontoHistorico))) +
#   geom_histogram() +
#   geom_vline(xintercept=quantile(log(x7$MontoHistorico), 0.25)[[1]], color="red") +
#   geom_vline(xintercept=quantile(log(x7$MontoHistorico), 0.75)[[1]], color = "red")
# 
# x8 <- defraudaciones %>% filter(MesD==8)
# ggplot(x8, aes(x=log(MontoHistorico))) +
#   geom_histogram() +
#   geom_vline(xintercept=quantile(log(x8$MontoHistorico), 0.25)[[1]], color="red") +
#   geom_vline(xintercept=quantile(log(x8$MontoHistorico), 0.75)[[1]], color = "red")
# 
# x9 <- defraudaciones %>% filter(MesD==9)
# ggplot(x9, aes(x=log(MontoHistorico))) +
#   geom_histogram() +
#   geom_vline(xintercept=quantile(log(x9$MontoHistorico), 0.25)[[1]], color="red") +
#   geom_vline(xintercept=quantile(log(x9$MontoHistorico), 0.75)[[1]], color = "red")
# 
# x10 <- defraudaciones %>% filter(MesD==10)
# ggplot(x10, aes(x=log(MontoHistorico))) +
#   geom_histogram() +
#   geom_vline(xintercept=quantile(log(x10$MontoHistorico), 0.25)[[1]], color="red") +
#   geom_vline(xintercept=quantile(log(x10$MontoHistorico), 0.75)[[1]], color = "red")
# 
# x11 <- defraudaciones %>% filter(MesD==11)
# ggplot(x11, aes(x=log(MontoHistorico))) +
#   geom_histogram() +
#   geom_vline(xintercept=quantile(log(x11$MontoHistorico), 0.25)[[1]], color="red") +
#   geom_vline(xintercept=quantile(log(x11$MontoHistorico), 0.75)[[1]], color = "red")
# 
# x12 <- defraudaciones %>% filter(MesD==12)
# ggplot(x12, aes(x=log(MontoHistorico))) +
#   geom_histogram() +
#   geom_vline(xintercept=quantile(log(x12$MontoHistorico), 0.25)[[1]], color="red") +
#   geom_vline(xintercept=quantile(log(x12$MontoHistorico), 0.75)[[1]], color = "red")



```













